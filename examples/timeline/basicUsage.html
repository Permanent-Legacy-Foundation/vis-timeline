<!DOCTYPE HTML>
<html>
<head>
  <title>Timeline | Basic demo</title>

  <style type="text/css">
    body, html {
      font-family: sans-serif;
    }

    .slideout-panel {
      will-change: transform;
    }
  </style>

  <script src="../../dist/vis-timeline-graph2d.min.js"></script>
  <link href="../../dist/vis-timeline-graph2d.min.css" rel="stylesheet" type="text/css" />

</head>
<body>
  <p>
      This example demonstrates how calling `timeline.setGroups(groups)` has a memory leak.
  </p>
  <p><strong><em>
      View your developer tools/inspector in the "Memory" tab to watch the current memory usage grow. The leak will be started 1 second after the page is 
      loaded, and will continue to leak every 150ms. NOTE: Make sure you're looking at the `fiddle.jshell.net` frame memory, (not jsfiddle.net) if viewing online.
  </strong></em></p>
  <p>
      The leak occurs simply when calling setGroups (or setData) with the same groups over and over.
  </p>
  <p>
      The number of items does not appear to affect this, and this issue does not appear to occur simply when setting items, or redrawing, only when using
      either setGroups or setData to set new groups.
  </p>
  <p>
      The issue appears to be in `Group.js`: `itemSet.body.emitter.on("checkRangedItems", ...fn...)` is called on all groups, ignoring whether or not the
      listener has already been registered on the emitter, leading to a leak of un-released listeners.
      A workaround is simply to `delete timeline._callers.checkRangedItems` before each redraw (or set new data).
  </p>
  <p>In this example, on my machine, I see ~65,000 callbacks and ~90mb memory usage after 60 seconds.</p>

  <p>timeline._callbacks.checkRangedItems.length: <span id="callback-count"></span></p>
  <div id="visualization"></div>
  
  <script>
      // -----------BEGIN BASIC TIMELINE SETUP-----------
      // create some groups with no items
      var groupCount = 25;
      var groups = new vis.DataSet();
      for (var g = 0; g < groupCount; g++) {
          groups.add({ id: g });
      }
      var container = document.getElementById('visualization');
      var timeline = new vis.Timeline(container);

      timeline.setData({ groups, items: [] });
      // -----------END BASIC TIMELINE SETUP-------------
      var numCallbacksContainer = document.getElementById('callback-count');

      // Here's the leaky loop
      function _createLeak() {
          for (let i = 0; i < 10; i++) {
              timeline.setGroups(groups); // <-- This function causes the leak
          }

          numCallbacksContainer.innerText = timeline._callbacks.checkRangedItems.length;

          setTimeout(() => _createLeak(), 150);
      }

      // wait 1s for initial render before starting to leak...
      setTimeout(_createLeak, 1000);
  </script>
</body>
</html>
